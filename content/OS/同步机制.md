# 同步互斥机制

## 进程的并发执行

进程并发执行有可能会导致一些读写错误（同步问题）

## 一、进程互斥

由于各进程要求使用**共享资源**（变量、文件等），而这些资源需要**排他性**使用。进程之间竞争使用这些资源。

**临界资源**：系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或者互斥资源、共享变量。

**临界区（互斥区）**：各个进程中对某个临界资源（共享变量）实施操作的程序片段

临界区使用原则：

- 如果没有进程在临界区 想进临界区的进程就可以进入临界区 
- 不允许两个进程同时处于临界区中
- 临界区外运行的进程，不能阻塞其他的进程进入临界区
- 不得使进程无限期的等待进入临界区

实现进程互斥的方案：

- 软件方案：Dekker解法、Peterson解法
- 硬件方案：屏蔽中断、TSL指令

### 进程互斥的软件解决方案

#### 方法1：

![](./image/sync2.png)

把上锁lock函数设计成一个原语（在执行过程中不允许被中断），同样，也把解锁函数封装成一个原语

#### 方法2：

![](./image/sync3.png)

turn=false,P进入不了临界区，但是Q又不想进入临界区

违反了“临界区外运行的进程，不能阻塞其他的进程进入临界区”原则

#### 方法3：

![](./image/sync4.png)

会造成“after you”问题，相互谦让，相互等待

#### 方法4：Dekker解法

![](./image/sync1.png)

turn 变量是相当于是一个枚举类型。由 turn 来决定谁进临界区。内层while一直在循环，直到它把它的时间片用完，被切换下CPU。 假定只有一个 CPU 的情况下，你在 CPU 上等，那谁上 CPU？ 没有进程上 CPU，所以你必须在 CPU 用完了时间片才能被切换下去，所以浪费了这些时间，就是说你不断地在测试，实际上是在浪费时间。

内层while循环会造成**忙等待**

#### 方法5：Peterson解法

![](./image/sync5.png)

如果两个进程同时想进临界区的话,因为 turn 是一个大家都可以往里头赋值的共享的变量，所以两个进程，比如说 0 和 1 都想进临界区，那就看谁先赋值给 turn，谁后赋值给 turn 。假设 0 号进程先赋值给 turn 那么后，后面的是 1 号进程赋值给 turn，因此先赋值给 turn 的那个值实际上就被后面赋值的这个覆盖掉了，所以 turn 里头始终保持是后面来的要想进临界区的进程的进程号。

最终效果：先赋值给turn的进程先进入临界区

### 进程互斥的硬件解决方案

#### 方法1：中断屏蔽方法

“开关中断”指令，过程：

- 执行“关中断”指令
- 执行临界区操作
- 执行“开中断指令”

原语操作实际上都是用这种方式实现的。

优缺点：

- 简单，高效
- 代价高，限制CPU并发能力（临界区范围设置得大，有些指令没有并发执行）
- 不适用于多处理器（因为开关中断只针对一个处理器）
- 适用于操作系统本身，不适用于用户进程

#### 方法2：“测试并加锁”指令

一条指令做了两个事情：1.先读一个内存单元内容到寄存器；2.把内存单元的内容写上某个值

![](./image/sync6.png)

- 这个 Lock 是一个内存单元，把这个内存单元的值，不管它前面是什么值，把它内容先复制到了寄存器，然后再把这内存单元的值设置成1。读和写操作是不分割的。即该指令结束之前其他处理器不允许访问该内存字。
- 判断寄存器的内容是不是0，如果是0说明原来的是没上锁的，那你要想上锁就把它锁上就可以了，锁上就可以进入临界区了。 所以如果是0那就直接返回调用者，那么就进入临界区了。 但如果不是0那就要去再次做测试（所以也有**busy waiting**问题）。

这条指令在总线级做了一些工作，通过把总线封锁，先读后写这个操作做完以后再把总线打开

#### 方法3：“交换”指令

![](./image/sync7.png)

#### 其他

忙等待busy waiting：进程在得到临界区的访问之前，持续做测试不做任何其他的事情，浪费了 CPU 的周期。所以在单处理器系统中要抛弃这种方法。

多处理器可以用这种方法。 某一个进程上了一个 CPU，想要进入临界区，想要加锁。在这个锁或临界区的访问权没有得到之前，它可以一直在保持测试。但是其它的 CPU 可以去 运行相应的进程，去把这个锁打开或者是把临界区还回来。

切换CPU 行不行呢？切换实际上会带来开销，因为临界区的使用应该是个很短的时间，所以很快就会有进程把临界区让出来。所以在这种情况下，一个进程在某一个 CPU 上持续做测试，是允许的，因为切换的开销比这个还要大。

**自旋锁spin lock**：在多处理器下，把忙等待的思路引入进来。如果我想得到临界区使用权，那么我首先要判断是不是有进程在临界区；如果有进程在临界区，那我就在那里自旋，不断地去测试，直到这个临界区还回来。

但是有可能会导致**优先级反转现象**的产生：考虑一台计算机有两个进程，H优先级高，L优先级低。调度规则规定，只要H处于就绪态就可以运行。某一时刻，L处于临界区中，此时H变到就绪态，准备运行。现在H开始忙等待，但由于当H就绪时L不会被调度，也就无法离开临界区，所以H将永远等待下去。

## 二、进程同步

进程互斥：竞争关系；进程同步：协作关系

进程同步：指多个进程中，发生的事件存在着某种时序关系，需要这些进程相互合作，共同完成一项任务。

具体来说：有多个进程，其中一个进程执行到了某一点，它要求另外一个进程为它提供消息。在没有获得这个消息的时候，那么前一个进程就要进入阻塞态，等这个消息，一旦这个消息到达，就把前面这个进程唤醒，让它重新就绪。（进程间有时序关系）

生产者消费者问题

### 信号量以及PV操作

信号量：一个特殊变量，用于进程间传递信息的整数值，定义如下：由一个值和一个队列组成

```
struct semaphore{
	int count;
	queueType queue;
}
```
可以对信号量实施的操作：初始化、P（test）、V(increment)

P、V操作定义

![](./image/sync8.png)

P、V操作是原语操作，不允许被中断。

### 用PV操作解决进程间互斥的问题

步骤：

- 分析并发进程的关键活动，划分临界区
- 设置信号量mutex（mutual exclusive缩写），初值为1
- 在临界区前实施P
- 在临界区后实施V

![](./image/sync9.png)

两个P操作的顺序不能调换（会死锁），但两个V操作的顺序可以调换

### 读写者问题

问题描述：多个进程共享一个数据区，这些进程分为两组：读者进程（只读数据区中的数据），写者进程（只往数据区写数据）

要求满足的条件：

- 允许多个
- 同时执行读操作
- 不允许多个写者同时操作
- 不允许读者、写者同时操作

#### 第一类读写者问题：读者优先

![](./image/sync10.png)

解法：

![](./image/sync11.png)

由于**允许多个读者同时执行读操作**，不需要每个读者都做PV操作。引入一个计数器，记录当前有多少个读者，由第一个读者做P操作，最后一个读者做V操作。

由于引入rc，又会产生新的问题。rc成为了新的临界资源，因此还要针对这样的临界区增加一个互斥的信号量。

![](./image/sync12.png)

## 三、管程

why管程？信号量机制以及PV操作的不足：程序编写困难、易出错。

- 管程定义

    是一个特殊的模块，有自己的名字，由关于共享资源的数据结构及在其上操作的一组过程组成。

- 进程与管程

    进程只能通过调用**管程中的过程**来间接地访问管程中的数据结构

### 管程需要解决的问题

- 互斥

    管程互斥进入，保证管程中的数据结构的数据完整性。这种**互斥由编译器负责保证**

- 同步

    管程中设置条件变量及等待/唤醒操作。让一个进程或线程在条件变量上等待（此时应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒。

### 应用管程时可能会遇到的问题

有多个进程同时在管程中出现：一个进程进入管程，发现对资源操作的条件不成熟，则休眠，释放管程的使用权。当后面进入管程的进程执行唤醒操作时（P唤醒Q），管程中就存在两个同时处于活动状态的进程。

解决：

- P等待Q执行（HOARE管程）
- Q等待P继续执行（MESA管程）
- 规定唤醒操作为管程中最后一个可执行的操作

### 管程的实现

- 直接构造，效率高
- 简洁构造，用某种已经实现的同步机制去构造

### HOARE管程

![](./image/sync13.png)

![](./image/sync14.png)

条件变量的实现：

条件变量是在管程内部说明和使用的一种特殊类型的变量，对于条件变量，可以执行wait和signal操作。

比如：定义 var c: condition;

wait(c)：如果**紧急等待队列**非空，则唤醒第一个等待者，否则释放管程的互斥权，执行此操作的进程进入c链末尾。

signal(c)：如果c链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾。
    
**应用：解决生产者消费者问题**

![](./image/sync15.png)

### MESA管程

HOARE管程的缺点：两次额外的进程切换

解决：signal -> notify

当一个正在管程中的进程执行notify(x)时，它使得x条件队列得到通知，发信号的进程继续执行。位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行。由于不能保证在它之前没有其他进程进入管程，因而这个进程必须重新检查条件：用while来取代if语句。

MESA管程导致对条件变量至少多一次额外的检测，并且对等待进程在notify之后何时运行没有限制。

### PTHREAD同步机制

### 进程间通信

基本方式：

- 消息传递
- 共享内存
- 管道
- 套接字
- 远程过程调用

消息传递：send & receive原语

![](./image/sync16.png)

共享内存：

![](./image/sync17.png)

管道：利用一个缓冲传输介质——内存或文件连接两个相互通信的进程

![](./image/sync18.png)