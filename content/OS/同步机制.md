# 同步互斥机制

## 进程的并发执行

进程并发执行有可能会导致一些读写错误（同步问题）

## 一、进程互斥

由于各进程要求使用**共享资源**（变量、文件等），而这些资源需要**排他性**使用。进程之间竞争使用这些资源。

**临界资源**：系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或者互斥资源、共享变量。

**临界区（互斥区）**：各个进程中对某个临界资源（共享变量）实施操作的程序片段

临界区使用原则：

- 如果没有进程在临界区 想进临界区的进程就可以进入临界区 
- 不允许两个进程同时处于临界区中
- 临界区外运行的进程，不能阻塞其他的进程进入临界区
- 不得使进程无限期的等待进入临界区

实现进程互斥的方案：

- 软件方案：Dekker解法、Peterson解法
- 硬件方案：屏蔽中断、TSL指令

### 进程互斥的软件解决方案

#### 方法1：

![](./image/sync2.png)
把上锁lock函数设计成一个原语（在执行过程中不允许被中断），同样，也把解锁函数封装成一个原语

#### 方法2：

![](./image/sync3.png)
turn=false,P进入不了临界区，但是Q又不想进入临界区

违反了“临界区外运行的进程，不能阻塞其他的进程进入临界区”原则

#### 方法3：

![](./image/sync4.png)
会造成“after you”问题，相互谦让，相互等待

#### 方法4：Dekker解法

![](./image/sync1.png)
turn 变量是相当于是一个枚举类型。由 turn 来决定谁进临界区。内层while一直在循环，直到它把它的时间片用完，被切换下CPU。 假定只有一个 CPU 的情况下，你在 CPU 上等，那谁上 CPU？ 没有人进程上 CPU，所以你必须在 CPU 用完了时间片才能被切换下去，所以浪费了这些时间，就是说你不断地在测试，实际上是在浪费时间。

内层while循环会造成**忙等待**

#### 方法5：Peterson解法

![](./image/sync5.png)

### 进程互斥的硬件解决方案

#### 方法1：中断屏蔽方法

“开关中断”指令，过程：

- 执行“关中断”指令
- 执行临界区操作
- 执行“开中断指令”

原语操作实际上都是用这种方式实现的。

优缺点：

- 简单，高效
- 代价高，限制CPU并发能力（临界区范围设置得大，有些指令没有并发执行）
- 不适用于多处理器（因为开关中断只针对一个处理器）
- 适用于操作系统本身，不适用于用户进程

#### 方法2：“测试并加锁”指令

一条指令做了两个事情：1.先读一个内存单元内容到寄存器；2.把内存单元的内容写上某个值

![](./image/sync6.png)

- 这个 Lock 是一个内存单元，把这个内存单元的值，不管它前面是什么值，把它内容先复制到了寄存器，然后再把这内存单元的值设置成1
- 判断寄存器的内容是不是0，如果是0说明原来的是没上锁的，那你要想上锁就把它锁上就可以了，锁上就可以进入临界区了。 所以如果是0那就直接返回调用者，那么就进入临界区了。 但如果不是0那就要去再次做测试（所以也有**busy waiting**问题）。

这条指令在总线级做了一些工作，通过把总线封锁，先读后写这个操作做完以后再把总线打开

#### 方法3：“交换”指令

![](./image/sync7.png)

#### 其他

忙等待busy waiting：进程在得到临界区的访问之前，持续做测试不做任何其他的事情，浪费了 CPU 的周期。所以在单处理器系统中要抛弃这种方法。

多处理器可以用这种方法。 某一个进程上了一个 CPU，想要进入临界区，想要加锁。在这个锁或临界区的访问权没有得到之前，它可以一直在保持测试。但是其它的 CPU 可以去 运行相应的进程，去把这个锁打开或者是把临界区还回来。

切换CPU 行不行呢？切换实际上会带来开销，因为临界区的使用应该是个很短的时间，所以很快就会有进程把临界区让出来。所以在这种情况下，一个进程在某一个 CPU 上持续做测试，是允许的，因为切换的开销比这个还要大。

**自旋锁spin lock**：在多处理器下，把忙等待的思路引入进来。如果我想得到临界区使用权，那么我首先要判断是不是有进程在临界区；如果有进程在临界区，那我就在那里自旋，不断地去测试，直到这个临界区还回来。

但是有可能会导致**优先级反转现象**的产生

## 二、进程同步

进程互斥：竞争关系；进程同步：协作关系

进程同步：指多个进程中，发生的事件存在着某种时序关系，需要这些进程相互合作，共同完成一项任务。

具体来说：有多个进程，其中一个进程执行到了某一点，它要求另外一个进程为它提供消息。在没有获得这个消息的时候，那么前一个进程就要进入阻塞态，等这个消息，一旦这个消息到达，就把前面这个进程唤醒，让它重新就绪。（进程间有时序关系）

生产者消费者问题

### 信号量以及PV操作

信号量：一个特殊变量，用于进程间传递信息的整数值，定义如下：由一个值和一个队列组成

```
struct semaphore{
	int count;
	queueType queue;
}
```
可以对信号量实施的操作：初始化、P（test）、V(increment)

P、V操作定义

![](./image/sync8.png)

P、V操作是原语操作，不允许被中断。

### 用PV操作解决进程间互斥的问题

步骤：

- 分析并发进程的关键活动，划分临界区
- 设置信号量mutex（mutual exclusive缩写），初值为1
- 在临界区前实施P
- 在临界区后实施V

![](./image/sync9.png)

两个P操作的顺序不能调换（会死锁），但两个V操作的顺序可以调换

### 读写者问题

问题描述：多个进程共享一个数据区，这些进程分为两组：读者进程（只读数据区中的数据），写者进程（只往数据区写数据）

要求满足的条件：

- 允许多个读者同时执行读操作
- 不允许多个写者同时操作
- 不允许读者、写者同时操作

#### 第一类读写者问题：读者优先

![](./image/sync10.png)

解法：

![](./image/sync11.png)

由于**允许多个读者同时执行读操作**，不需要每个读者都做PV操作。引入一个计数器，记录当前有多少个读者，由第一个读者做P操作，最后一个读者做V操作。

由于引入rc，又会产生新的问题。rc成为了新的临界资源，因此还要针对这样的临界区增加一个互斥的信号量。

![](./image/sync12.png)