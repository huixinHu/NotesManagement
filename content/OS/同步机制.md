## 同步互斥机制

### 进程的并发执行

进程并发执行有可能会导致一些读写错误（同步问题）

### 进程互斥

由于各进程要求使用**共享资源**（变量、文件等），而这些资源需要**排他性**使用。进程之间竞争使用这些资源。

**临界资源**：系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或者互斥资源、共享变量。

**临界区（互斥区）**：各个进程中对某个临界资源（共享变量）实施操作的程序片段

临界区使用原则：

- 如果没有进程在临界区 想进临界区的进程就可以进入临界区 
- 不允许两个进程同时处于临界区中
- 临界区外运行的进程，不能阻塞其他的进程进入临界区
- 不得使进程无限期的等待进入临界区

实现进程互斥的方案：

- 软件方案：Dekker解法、Peterson解法
- 硬件方案：屏蔽中断、TSL指令

### 进程互斥的软件解决方案

方法1：
![](./image/sync2.png)
把上锁lock函数设计成一个原语（在执行过程中不允许被中断），同样，也把解锁函数封装成一个原语

方法2：
![](./image/sync3.png)
turn=false,P进入不了临界区，但是Q又不想进入临界区

违反了“临界区外运行的进程，不能阻塞其他的进程进入临界区”原则

方法3：
![](./image/sync4.png)
会造成“after you”问题，相互谦让，相互等待

方法4：Dekker解法
![](./image/sync1.png)
turn 变量是相当于是一个枚举类型。由 turn 来决定谁进临界区。内层while一直在循环，直到它把它的时间片用完，被切换下CPU。 假定只有一个 CPU 的情况下，你在 CPU 上等，那谁上 CPU？ 没有人进程上 CPU，所以你必须在 CPU 用完了时间片才能被切换下去，所以浪费了这些时间，就是说你不断地在测试，实际上是在浪费时间。

内层while循环会造成**忙等待**

方法5：Peterson解法
![](./image/sync5.png)
