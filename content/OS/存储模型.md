## 基本概念

### 地址重定位

别名：地址转换、地址映射、地址翻译

概念：为了保证cpu执行指令时可以正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址

- 逻辑地址（相对地址）
 
    用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址。**不能用逻辑地址在内存中读取信息**

- 物理地址（绝对地址）

    内存中存储单元的地址，可以直接寻址

静态重定位：当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换，一般可由软件完成

动态重定位：在进程执行过程中进行地址变换（逐条指令执行时完成地址转换）。需要硬件支持

## 物理内存管理

### 空闲内存管理

物理内存的划分方法：等长划分、不等长划分。

管理空闲区的数据结构：

- 位图。（等长划分）
- 空闲区表、已分配区表 （不等长划分）
- 空闲块链表 （不等长划分）

### 内存分配算法

- 首次适配：在空闲区表中找到第一个满足进程要求的空闲区
- 下次适配：从上次找到的空闲区处接着查找
- 最佳适配：查找整个空闲区表，找到能够满足进程要求的最小空闲区
- 最差适配：总是分配满足进程要求的最大空闲区

当找到满足要求的空闲区后，将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区

### 回收问题

内存回收算法：当某一块内存归还后，前后空闲空间合并，修改内存空闲区表

四种情况：上相邻、下相邻、上下都相邻、上下都不相邻

## 伙伴系统

伙伴系统是一种经典的内存分配方案

主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块。

分配算法：

![](./image/store1.png)

## 基本内存管理方案1

单一连续区、固定分区、可变分区

特点：整个进程进入内存中的一片连续区域

### 单一连续区

一段时间内只有一个进程在内存。简单、内存利用率低

三种布局：

![](./image/store2.png)

### 固定分区

- 把内存空间分割成若干区域，称为分区
- 每个分区的大小可以相同也可以不同
- 分区大小固定不变
- 每个分区装一个且只能装一个进程

### 可变分区

- 根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程
- 剩余部分成为新的空闲区

![](./image/store3.png)

问题：产生空闲区（外）碎片，导致内存利用率下降

**解决碎片问题**

方案：紧缩技术（压缩技术、紧致技术、搬家技术） —— 在内存移动程序，将所有小的空闲区合并为较大的空闲区。

需要考虑的问题：系统开销、移动时机

## 基本内存管理方案2

页式、段式、段页式

特点：一个进程进入内存中若干不连续的区域

### 页式存储

- 用户进程地址空间被划分为大小相等的部分，称为页或页面，从0开始编号。
- 内存空间按同样大小划分为大小相等的区域，称为页框（page frame），从0开始编号；也称为物理页面，页帧，内存块

内存分配（规则）：以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻。

典型页面尺寸：4K或4M

逻辑地址的划分：是由系统自动划分的，结构见下图

![](./image/store4.png)

![](./image/store5.png)

页表项：记录了逻辑页号与页框号的对应关系。

每个进程一个页表，存放在内存中

空闲物理内存管理 —— 使用位图

**地址转换**的完成需要硬件支持。CPU取到逻辑地址，自动划分为页号和页内地址，用页号查页表，得到页框号，再与页内偏移拼接成物理地址。

### 段式存储

- 用户进程地址空间：按照程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名。
- 内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段**由起始地址和长度确定**

内存分配规则：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻

逻辑地址构成与页式存储相似：段号+段内地址。但它不是自动划分的

![](./image/store6.png)

![](./image/store7.png)

### 段页式存储

用户进程划分：先按段划分，每一段再按页面划分

逻辑地址：

![](./image/store8.png)

内存划分：同页式存储管理方案——等长划分

内存分配：以页为单位进行分配

### 其他

在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。 外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。 固定分区存在内部碎片，可变式分区分配会存在外部碎片； 页式虚拟存储系统存在内部碎片；段式虚拟存储系统，存在外部碎片 为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。 为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。

## 交换技术

问题：一个大的进程地址空间怎样装入小的可用的**物理内存**。（内存不足的时候要如何管理）如何在较小的内存空间里头运行一个较大的进程。

采用内存“扩充”技术（不是指新买一个内存条然后把物理内存扩大）

- 内存紧缩技术（例如：可变分区）
- 覆盖技术
- 交换技术
- 虚拟存储技术

内存紧缩技术：可变分区存储管理方案中，会出现碎片问题。那么由于系统中有很多碎片，可能会导致一个进程不可以进入内存。因为碎片虽然很多，碎片的综合能够满足进程的需求，但是由于碎片都分散在不同的位置，所以这个进程还是进入不了内存。

### 覆盖技术

要解决的问题：程序大小超过物理内存总和

在程序执行过程中，程序的不同部分在内存中相互替代。按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域。

要求程序各模块之间有明确的调用结构。

程序员声明覆盖结构，操作系统完成自动覆盖。

主要用于早起的操作系统。

缺点：对用户不透明，增加了用户负担。

### 交换技术

设计思想：内存空间紧张时，系统将内存中某些进程暂时移到外存（磁盘），把外存中某些进程换进内存，占据前者所占用的区域。（进程在内存与磁盘之间动态调度）

几个问题：

**交换的内容**？运行时创建或修改的内容：栈和堆。

**在磁盘的什么位置保存被交换出的进程**？交换区：一般系统会制定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，（这块区域不经过文件系统）操作系统可以使用底层的磁盘读写操作对其高效访问。在windows系统中叫做“页文件”pagefile

**交换时机**？只要不用就换出去（很少再用）；或者内存空间不够、有不够的危险时就换出去。这个过程与调度器结合使用

**如何选择被换出的进程**？考虑进程的各种属性；不应该换出处于等待IO状态的进程

**如何处理进程空间的增长**？数据段和栈段，两种增长方案：

![](./image/store9.png)
