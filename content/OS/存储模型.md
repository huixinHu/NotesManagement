## 一、基本概念

### 地址重定位

别名：地址转换、地址映射、地址翻译

概念：为了保证cpu执行指令时可以正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址

- 逻辑地址（相对地址）
 
    用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址。**不能用逻辑地址在内存中读取信息**

- 物理地址（绝对地址）

    内存中存储单元的地址，可以直接寻址

静态重定位：当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换，一般可由软件完成

动态重定位：在进程执行过程中进行地址变换（逐条指令执行时完成地址转换）。需要硬件支持

## 二、物理内存管理

### 空闲内存管理

物理内存的划分方法：等长划分、不等长划分。

管理空闲区的数据结构：

- 位图。（等长划分）
- 空闲区表、已分配区表 （不等长划分）
- 空闲块链表 （不等长划分）

### 内存分配算法

- 首次适配：在空闲区表中找到第一个满足进程要求的空闲区
- 下次适配：从上次找到的空闲区处接着查找
- 最佳适配：查找整个空闲区表，找到能够满足进程要求的最小空闲区
- 最差适配：总是分配满足进程要求的最大空闲区

当找到满足要求的空闲区后，将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区

### 回收问题

内存回收算法：当某一块内存归还后，前后空闲空间合并，修改内存空闲区表

四种情况：上相邻、下相邻、上下都相邻、上下都不相邻

## 三、伙伴系统

伙伴系统是一种经典的内存分配方案

主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块。

分配算法：

![](./image/store1.png)

## 四、基本内存管理方案1

单一连续区、固定分区、可变分区

特点：整个进程进入内存中的一片连续区域

### 单一连续区

一段时间内只有一个进程在内存。简单、内存利用率低

三种布局：

![](./image/store2.png)

### 固定分区

- 把内存空间分割成若干区域，称为分区
- 每个分区的大小可以相同也可以不同
- 分区大小固定不变
- 每个分区装一个且只能装一个进程

### 可变分区

- 根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程
- 剩余部分成为新的空闲区

![](./image/store3.png)

问题：产生空闲区（外）碎片，导致内存利用率下降

**解决碎片问题**

方案：紧缩技术（压缩技术、紧致技术、搬家技术） —— 在内存移动程序，将所有小的空闲区合并为较大的空闲区。

需要考虑的问题：系统开销、移动时机

## 五、基本内存管理方案2

页式、段式、段页式

特点：一个进程进入内存中若干不连续的区域

### 页式存储

- 用户进程地址空间被划分为大小相等的部分，称为页或页面，从0开始编号。
- 内存空间按同样大小划分为大小相等的区域，称为页框（page frame），从0开始编号；也称为物理页面，页帧，内存块

内存分配（规则）：以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻。

典型页面尺寸：4K或4M

逻辑地址的划分：是由系统自动划分的，结构见下图

![](./image/store4.png)

![](./image/store5.png)

页表项：记录了逻辑页号与页框号的对应关系。

每个进程一个页表，存放在内存中

空闲物理内存管理 —— 使用位图

**地址转换**的完成需要硬件支持。CPU取到逻辑地址，自动划分为页号和页内地址，用页号查页表，得到页框号，再与页内偏移拼接成物理地址。

### 段式存储

- 用户进程地址空间：按照程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名。
- 内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段**由起始地址和长度确定**

内存分配规则：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻

逻辑地址构成与页式存储相似：段号+段内地址。但它不是自动划分的

![](./image/store6.png)

![](./image/store7.png)

### 段页式存储

用户进程划分：先按段划分，每一段再按页面划分

逻辑地址：

![](./image/store8.png)

内存划分：同页式存储管理方案——等长划分

内存分配：以页为单位进行分配

### 其他

在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。 外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。 固定分区存在内部碎片，可变式分区分配会存在外部碎片； 页式虚拟存储系统存在内部碎片；段式虚拟存储系统，存在外部碎片 为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。 为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。

## 六、交换技术

问题：一个大的进程地址空间怎样装入小的可用的**物理内存**。（内存不足的时候要如何管理）如何在较小的内存空间里头运行一个较大的进程。

采用内存“扩充”技术（不是指新买一个内存条然后把物理内存扩大）

- 内存紧缩技术（例如：可变分区）
- 覆盖技术
- 交换技术
- 虚拟存储技术

内存紧缩技术：可变分区存储管理方案中，会出现碎片问题。那么由于系统中有很多碎片，可能会导致一个进程不可以进入内存。因为碎片虽然很多，碎片的综合能够满足进程的需求，但是由于碎片都分散在不同的位置，所以这个进程还是进入不了内存。

### 覆盖技术

要解决的问题：程序大小超过物理内存总和

在程序执行过程中，程序的不同部分在内存中相互替代。按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域。

要求程序各模块之间有明确的调用结构。

程序员声明覆盖结构，操作系统完成自动覆盖。

主要用于早起的操作系统。

缺点：对用户不透明，增加了用户负担。

### 交换技术

设计思想：内存空间紧张时，系统将内存中某些进程暂时移到外存（磁盘），把外存中某些进程换进内存，占据前者所占用的区域。（进程在内存与磁盘之间动态调度）

几个问题：

**交换的内容**？运行时创建或修改的内容：栈和堆。

**在磁盘的什么位置保存被交换出的进程**？交换区：一般系统会制定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，（这块区域不经过文件系统）操作系统可以使用底层的磁盘读写操作对其高效访问。在windows系统中叫做“页文件”pagefile

**交换时机**？只要不用就换出去（很少再用）；或者内存空间不够、有不够的危险时就换出去。这个过程与调度器结合使用

**如何选择被换出的进程**？考虑进程的各种属性；不应该换出处于等待IO状态的进程

**如何处理进程空间的增长**？数据段和栈段，两种增长方案：

![](./image/store9.png)

## 七、虚拟存储技术

虚拟存储技术——当进程运行时，先将其**一部分装入内存，另一部分暂留在磁盘**，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将他们从磁盘调入内存的工作。

引入虚拟存储技术后，每个进程的地址空间，称之为**虚拟地址空间**（分配给进程的**虚拟内存**）。

**虚拟地址**：在虚拟内存中的指令或者数据的位置（虚拟地址空间中的地址），该位置可以被访问，**仿佛**是内存的一部分。

虚拟内存在哪里？

存储器的层次结构如下：

![](./image/store10.png)

进程的地址空间（虚存），建立在以上（图）存储体系之上，它的一部分内容在内存，一部分在磁盘。是对内存的抽象，由操作系统协调各个存储器的使用。

虚存的速度与CPU的取址速度相当，但虚存提供了一个比物理内存空间大得多的地址空间。

虚存的大小受计算机系统的寻址机制、磁盘空间中的可用空间这两方面的限制。比如32位计算机，虚拟地址空间可以达到2^32即4G。

### 地址保护

- 确保进程有独立的地址空间
- 确保进程访问合法的地址范围（防止地址越界）
- 确保进程的操作时合法的（防止访问越权）

### 虚拟页式存储

虚拟存储技术+页式存储管理方案

方式：

- 请求调页（常用）
- 预先调页

基本思想：

- 进程开始运行之前，不是装入全部页面，而是装入一个或零个页面
- 之后，根据进程运行的需要，动态装入其他页面
- 当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中某个页面，一边装入新的页面

用CPU时间和磁盘时间换取昂贵的内存空间 —— 资源转换技术

## 八、页表及页表项的设计

![](./image/store11.png)

这张图中，不是所有的虚拟地址空间的虚页面都加载到内存。通过页表，记录哪些页面已经加载到内存。页表由页表项组成。

### 页表项设计

通常，页表项是由硬件设计的。（地址转换由硬件完成，硬件需要访问页表）

![](./image/store12.png)

### 页表

虚拟地址被分为虚拟页号（高位部分）和偏移量（低位部分）两部分，比如对于16位地址和4KB的页面大小，高4位可以指定16个虚拟页面中的一页，而低12位确定所选页面中的字节偏移量。

虚拟页号可以做页表的索引，找到该虚拟页面对应的页表项，由页表项找到页框号

QUESTION:32位虚拟地址空间的页表规模？假设页面大小为4K，页表项为4字节。

ANSWER:一个进程地址空间有2^20页，页表需要1024页。

QUESTION:64位呢？假设页面大小4K，页表项8字节。

ANSWER:页表规模：32000TB

**如何解决巨大的虚拟地址空间？**1.多级页表 2.倒排页表

页表不应该连续存放在内存。如果不连续存放，那么要引入一个新的页表页来保存这些页表页的地址，称之为**页目录**（页表页的地址索引表）。引申出多级页表结构。

一个进程上CPU时，页目录的起始地址存放在一个寄存器中。当进程下CPU时，页目录的起始地址保存在这个进程的PCB相关的现场信息中。

### 多级页表

以下基于32位虚拟地址空间的例子：

![](./image/store13.png)

二级页表可以表示4G的虚拟地址空间

### 反转（倒排）页表

之前说到的页表，地址转换过程：从虚拟地址空间出发，虚拟地址 -> 查页表 -> 得到页框号 ->形成物理地址

**每个进程**一张页表，这个页表是非常巨大的，占据了很多的空间即便是在内存当中，不连续存放，那么你也需要花很多的空间来存放页表。

解决思路：从物理地址空间出发，**整个系统**建立一张页表（从物理地址映射到虚拟地址）。在实际内存中每个页框有一个表项，而不是每一个虚拟页面有一个表项。页表项记录哪一个**（进程，虚拟页面）对**定位于该页框。【ppt:页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系】

缺点：从虚拟地址到物理地址的转换变得困难。比如，当进程n访问虚拟页面p时，必须搜索整个倒排页表来查找某个表项(n,p)。而且，该搜索必须对每一个内存访问操作都要执行一次。

解决方法：使用TLB，记录频繁使用的页面。但TLB失效时，需要用软件搜索整个倒排列表，可以建立散列表，用虚拟地址来散列。


## 九、地址转换过程和TLB

地址转换是由MMU来完成的。MMU：内存管理单元，属于硬件设备。

![](./image/store14.png)

存在的问题：1.页表需要两次或两次以上的内存访问（多级页表多次访问），2.CPU的指令处理速度与内存指令的访问速度差异大，CPU的速度得不到充分利用。

那么要如何**加快地址映射速度**，以改善系统性能呢？

利用**程序访问的局部性原理**，引入**快表**（TLB，translation look-aside buffers）。又称**相联存储器**，特点：按内容并行查找。

大多数程序总是对少量的页面进行多次访问，只有少量页表项会被反复读取而其他的页表项很少被访问。TLB**将虚拟地址直接映射到物理地址**，而不必再访问页表。

TLB是在CPU中引入的**高速缓存Cache**，可以匹配CPU的处理速率和内存的访问速度。具体组织：一种随机存取型存储器，除了连线寻址机制外，还有接线逻辑，能按特定的匹配标志，在一个存储周期内对**所有**的字同时进行比较。

快表的**大小**：按页表项来算，64项或者128项。像高速缓存一样，也可以分成几级。

快表**的位置**：CPU

### TLB的工作过程

将一个虚拟地址放入MMU中进行转换时，应将首先通过将该虚拟页号与TLB中所有表项同时（并行）进行匹配，判断虚拟页面是否在其中。如果发现了一个有效的匹配并且要进行的访问操作并不违反保护位，则将页框号直接从TLB中取出而不必再访问页表。

当虚拟页号不在TLB中时，就会进行正常的页表查询，接着从TLB中淘汰一个表项，然后用新找到的页表项代替它。

快表是由Cache组成，所以成本比较高，因此快表的容量比较小。保存正在运行进程的页表的**子集**（部分页表项）。由于快表小，需要考虑置换问题。

### 页错误（页故障）page fault

在地址转换过程中，硬件产生异常。典型异常：

- 缺页异常：所访问的虚拟页面没有调入物理内存
- 页面访问违反权限（读/写、用户/内核）
- 错误的访问地址

缺页异常的讨论：

![](./image/store15.png)