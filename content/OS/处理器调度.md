## 1.CPU调度相关概念

### CPU调度

其任务是控制、协调进程对CPU的竞争，即按一定的调度算法从**就绪队列**中选择一个进程，把CPU的使用权交给被选中的进程。

如果没有就绪进程，系统会安排一个**系统空闲进程或者idle进程**

三个问题：调度算法、调度时机、调度过程

### CPU调度的时机

- 进程正常终止或由于某种错误而终止
- 新进程创建或一个等待进程变成就绪
- 当一个进程从运行态进入阻塞态
- 当一个进程从运行态变为就绪态

什么时候重新调度？

往往是内核对中断、陷入系统调用等处理之后返回到用户态的时候，这个时候要重新调度

### 调度过程——进程切换

- 进程调度程序从就绪队列选择了要运行的进程。进程可以是刚刚被暂停执行的进程，也可能是另一个新的进程。如果是新的进程，就要发生**进程切换**

进程切换的工作内容：

- 切换全局页目录以加载一个新的地址空间
- 切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，例如CPU相关寄存器

切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复。

![](./image/cpu1.png)

### 上下文切换开销（COST）

- 直接开销：内核完成切换所用的CPU时间
 1. 保存和恢复寄存器
 2. 切换地址空间（相关指令比较昂贵）
- 间接开销
 1. 高速缓存、缓冲区缓存和TLB失效（高速缓存里头存放了一些刚才执行的进程当中的一些指令和数据。TLB快表存放了这个进程的一些页表表项。新的进程上 CPU 之后，原来的这些内容都失效了。 还要把新的进程所需要的指令数据，送入高速缓存或者是把新的进程的页表表项送入 TLB 快表里）

### 调度算法衡量指标

- 吞吐量：每单位时间内完成的进程数目
- 周转时间：每个进程从提出请求到运行完成的时间
- 响应时间：从提出请求到第一次回应的时间
- CPU利用率：CPU做有效工作的时间比例
- 等待时间：每个进程在就绪队列中等待的时间

## 2.设计调度算法要考虑的几个问题

- 进程控制块PCB要记录哪些与CPU调度有关的信息
- 进程优先级与就绪队列的组织
- 抢占式调度与非抢占式调度
- I/O密集型与CPU密集型
- 时间片

1.进程优先级（数）

优先级/优先数，静态优先级/动态优先级

2.进程就绪队列组织

- 按优先级来组织就绪队列
- 其他排队方式

3.抢占、非抢占（占用CPU的方式）

- 可抢占式（可剥夺式）

    当有比正在运行进程优先级更高的进程就绪的时候，系统可以强行剥夺正在运行进程的 CPU ，然后把它提供给具有更高优先级的进程。
- 不可抢占

    当某一个进程被调度运行之后，除非由于它自身的原因放弃了 CPU，否则这个进程一直运行下去

4.I/O密集型与CPU密集型

5.时间片

一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度。考虑的因素：

- 进程切换开销
- 对响应时间的要求
- 就绪进程个数
- CPU能力
- 进程的行为

## 3.批处理系统的调度算法

有以下几种算法：

- 先来先服务
- 最短作业优先
- 最短剩余时间优先
- 最高响应比优先

指标：吞吐量、周转时间、CPU利用率

### 先来先服务

先进先出，按照进程就绪的先后顺序使用CPU，是非抢占式的。

优缺点：

- 公平
- 实现简单
- 长进程之后的进程要等待很长时间，用户体验不好

### 最短作业优先

具有最短完成时间的进程优先执行，是非抢占式的

- 最短平均周转时间
- 不公平。源源不断的短任务到来，可能使得长任务得不到运行，产生**“饥饿”**现象

### 最短剩余时间优先

抢占式版本的最短作业优先算法

### 最高响应比优先

折衷权衡。是一个综合的算法，调度时先计算每个进程的响应比R，之后总是选择R最大的进程执行

R = 周转时间/处理时间 = （处理时间+等待时间）/处理时间

## 4.交互式系统调度算法

有以下几种算法：

- 轮转调度
- 最高优先级调度
- 多级反馈队列
- 最短进程优先

指标：响应时间

### 时间片轮转调度

![](./image/cpu2.png)

目标：为短任务改善平均响应时间

思路：

- 周期性切换
- 每个进程分配一个时间片
- 时钟中断->轮换

优缺点：

- 公平
- 有利于交互式计算，响应时间快
- 由于进程切换，要花费较高的开销
- 对不同大小的进程是有利的

使用**虚拟轮转法**改善对IO型进程的不公平性

### 最高优先级调度

选择优先级最高的进程投入运行

通常：系统进程优先级>用户进程，前台进程优先级>后台进程，操作系统更偏好I/O型进程

优缺点：

- 实现简单
- 不公平，饥饿现象

基于抢占式的优先级调度：优先级反转问题。现象：一个低优先级进程持有一个高优先级进程所需要的资源，是的高优先级进程等待低优先级进程运行

![](./image/cpu4.png)

### 多级反馈队列

折衷权衡。对I/O型进程更偏好一点

![](./image/cpu5.png)

![](./image/cpu6.png)

当创建一个新的进程时，所有的进程都进入第一级队列。如果是 I/O 型的进程，那么它可能被调度上 CPU 之后很短时间就去等待 I/O 当它从等待队列又回到就绪队列的时候。由于我们让它回到原来一级就绪队列，所以它优先级没有降低，被调度上 CPU 的机会很多。 但是对于 CPU 型的进程，它被调度上CPU，用完了一个时间片之后它就会回到下一级队列（降级），如果每次都用完了它的时间片，那么就可能导致CPU型的进程慢慢降到了优先级最低的队列里头。

通过这样一个调度算法，就可以慢慢地区分出来哪些进程是 CPU 型进程，哪些进程是 I/O 型进程，很显然多级反馈队列调度算法对 I/O 型进程更偏好一点，对 CPU 型进程不太有利。但是它也做了一些弥补，比如说优先级高的队列时间片短，而优先级低的队列时间片会很大

## windows现成调度算法

典型系统采用的调度算法
![](./image/cpu3.png)

### Windows线程调度

调度单位：线程

采用基于动态优先级、抢占式调度，结合时间配额的调整

 - 就绪线程是按照优先级进入不同的就绪队列 
 - 操作系统总是选择优先级最高的线程投入运行 
 - 同一优先级的各个线程是按照时间片轮转的方式进行调度的 
 - 多 CPU 系统中允许多个线程并行执行

在 Windows 操作系统中，引发线程调度的条件，除了之前介绍的四个条件之外（见“CPU调度的时机”），还增加了两个条件：

第一个是，**线程的优先级改变**会引发线程调度。 Windows使用32个线程优先级，分成三类：实时优先级（16-31）、可变优先级（1-15）、系统线程（0）

第二个是**一个线程改变了它的亲和处理机集合**，我们简单解释一下什么是一个线程的亲和处理机集合？ 有这样一个处理机的集合：有几个处理机，允许这个线程在这几个处理机上执行。除了这几个处理机之外其他的处理机空闲，那么这个线程也不能执行。这就是这个集合就是这个线程的亲和处理机集合。如果这个集合改变了，也就是说比如说增加了一个新的处理机在这个集合当中，那么就可以引发新的线程调度

### Windows线程调度策略

- 主动切换
- 抢占
- 时间配额用完

一个线程用完了时间配额会发生以下两种情况：1.优先级不变 2.优先级降低

为什么会优先级降低：因为这个线程在此之前，它的优先级曾经被提升过

### 线程优先级提升

Windows 的调度策略中：
- 如何体现对某类线程具有倾向性呢？
- 如何解决由于调度策略中，潜在的不公平性而带来的一些饥饿现象呢？
- 如何改善系统的吞吐量、 响应时间等整体特征呢？ 

通常的解决方案就是：**提升线程的优先级，给线程分配一个更大的时间配额**

5种情况会提升线程优先级：

 - I/O 操作完成
 - 信号量或事件等待结束
 - 前台进程中的线程完成了一个等待操作
 - 由于窗口活动而唤醒了窗口线程
 - 线程处于就绪态超过了一定的时间还没有被调度运行——"饥饿"现象