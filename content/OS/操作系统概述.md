##概述

### helloworld程序的执行过程

- 启动程序执行。告诉操作系统要执行程序：比如命令行输入命令、或者双击程序图标。
- 操作系统根据用户提供的文件名，到磁盘上找到这个程序的相关信息，检查这个程序是不是可执行文件。（如果不是就会报错）
- 在检查完类型之后，操作系统会根据程序首部信息来确定代码和数据在这个可执行文件当中的位置，并计算出它相应的磁盘块地址 
- 为了执行程序，操作系统要先创建一个新进程，并将程序的可执行文件格式映射到进程结构，表示由该进程来执行这个程序。
- **操作系统把控制权交给调度程序**，我们假设调度程序正好选中了helloworld程序，那么由操作系统为这个helloworld程序设置CPU上下文环境，并跳到程序的开始之处，准备执行这条这个程序。下一个指令周期就是执行helloworld程序了。
- 执行程序时发生缺页异常。程序在执行的时候，先要把程序的代码和数据读入内存，CPU才能去执行，但是helloworld程序的代码和数据还没有读入内存，所以这个时候硬件机制就会捕获出缺页异常，并且**把控制权交给操作系统**

操作系统管理了计算机系统中的内存，比如说，有页式存储管理方案的话，那么内存就有很多很多的物理页面。操作系统的内存管理模块，就会分配一页空闲的物理内存，并且根据前面计算出的磁盘块地址把helloworld程序的代码读入内存，然后继续执行helloworld程序。有的时候程序很大 一页内存还不够，因此在这个执行过程中会多次地产生缺页异常，然后去到磁盘读入程序到内存，这个过程会有多次。

- helloworld程序执行puts函数。那么puts函数的作用，是在标准的输出设备上显示字符串。puts函数它实际上是一个系统调用，是由操作系统来完成这个功能，所以**控制权又转回到操作系统**
- 操作系统找到要将字符串送到哪一个显示设备。通常这个设备是由一个进程控制的，所以操作系统把要写的字符串实际上是送给了这个进程。那么控制设备的进程，会告诉设备的窗口系统，它要显示字符串。
- 窗口系统确定这是一个合法的操作，然后将字符串转换为像素，把像素写入设备的存储映像区 以下就是视频硬件的工作。
- 视频硬件将像素，转换成显示器可以接收的一组控制信号或数据信号，那么显示器再去解释这个信号，激发液晶屏

![](./image/os1.png)

### 操作系统三个作用

1.操作系统是资源的管理者

2.向用户提供各种服务

3.屏蔽硬件细节，为用户提供一个 扩展的虚拟机器

### 操作系统主要工作

- 程序的执行：启动、执行、结束程序
- 完成与体系结构相关的工作。*重要
- 完成应用程序所需的共性任务，提供基本服务
- 性能、安全、健壮问题

![](./image/os2.png)

## 中断与异常

### CPU中央处理器

CPU由运算器 控制器、一系列的**寄存器**以及高速缓存构成。

寄存器：

- 用户可见寄存器：高级语言编译器通过优化算法分配这些寄存器，并且使用这些寄存器。主要的目的是为了减少访问内存的次数，来提高程序的运行效率。
- 控制和状态寄存器：用于控制处理器的操作，那么通常呢是**只能由操作系统**代码来使用。在某种特权级别下可以访问、修改。 

![](./image/os3.png)

### 操作系统对硬件的需求——保护

因为操作系统运行在一个多进程的这样一个环境下，支持这些进程的运行。 因此我们从操作系统的特征来考虑: 并发、 共享。 

操作系统为多个程序的执行提供了一个并发的环境，那么多个进程之间呢又共享操作系统所管理的各种资源。 那么这样一个并发、 共享的计算环境就要求保护。保护用户程序与用户程序之间互不干扰，保护用户程序不对操作系统干扰。 

通常，我们对硬件希望提供这样的一个基本运行机制。 也就是 CPU 它具有一个特权级别，**在不同的特权级下可以运行不同的指令集合**。 这样把指令分成不同的集合，那么供**操作系统**和**用户程序**分别使用。 那么通过保护呢又使得操作系统与用户能够相隔离。 比如说当要访问操作系统空间的时候，那么用户程序是不能够访问的。 那么操作系统可以访问用户程序空间，因此达到了，通过一个保护机制能够达到操作系统与用户的隔离。 

### CPU状态

现代处理器通常把 CPU 的状态设计为两种、 三种、 或者是四种。 那么在 CPU 上 时而运行操作系统、 时而运行用户程序，那么 CPU 如何知道是运行哪一种状态呢？ 这样就有赖于一些寄存器的某些位的设置。 通常呢是在程序状态字寄存器 PSW 当中呢来专门设置一位，有的时候是两位。根据运行程序**对资源和指令的权限**不同，来设置不同的 CPU 状态。

### 操作系统状态

操作系统需要两种 CPU 状态，一种是用于内核态：运行操作系统的代码；另一种是用户态：运行用户程序。

两个状态指向不同的指令集合。因此我们把指令的集合划分成两类：

- 特权指令，只能够由操作系统来使用
- 非特权指令，是用户可以使用的指令

访管指令：非特权指令。使得用户程序从用户态陷入操作系统内核态。作用是提供给用户程序的一个接口，使用户程序可以向操作系统提出各种服务请求

有了不同的特权级别，那么就需要让用户程序和操作系统之间能有转换。用户程序在执行的过程中如果需要操作系统的服务，它就要从用户态能够**陷入**内核态 而从用户态进入内核态的一个唯一的途径实际上就是中断/异常/陷入机制。

内核态->用户态：设置程序状态字寄存器
用户态->内核态：访管指令

### 中断、异常

是 CPU 对系统发生的某个事件的一种反应。当这个事件发生的时候通过对这个事件的处理实际上是改变了处理器的控制流。

发生了事件之后 CPU 会暂停正在执行的程序，保留现场。 然后自动转去执行对这个事件的处理程序（这个过程是由硬件来完成的，硬件自动地完成整个控制流的转移工作），完成之后，返回到断点继续执行刚才被打断的程序。

### 中断和异常的划分

中断（外中断，外部事件、CPU之外产生的事件）：IO中断、时钟中断、硬件故障（奇偶校验错）
异常（内中断，由正在执行的指令引发）：系统调用、页故障、页错误、保护性异常、断点指令、其他程序性异常（算术溢出）

异常分类：陷入（是程序中可以安排的）、故障、终止

### 中断和异常机制工作原理

1.硬件做的事情： ————中断/异常响应

捕获中断源发出的各种中断/异常的请求，以某一种方式来响应，把控制权转交给特定的处理程序

软件做的事情： ————中断/异常处理程序

2.识别中断、异常的类型，完成对应的处理

CPU要做的事情：

![](./image/os4.png)

中断向量表：

- 中断向量：一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字。

执行流程按中断号/异常类型的不同，通过中断向量表转移控制权给中断处理程序

![](./image/os5.png)

### 系统调用机制

系统调用：用户在编程时可以调用的操作系统功能

系统调用时操作系统提供给编程人员的唯一接口，使得CPU状态从用户态陷入内核态。系统调用的例子：进程控制、进程通信、文件使用、目录操作、设备管理、信息维护。

#### 系统调用的执行过程

当CPU执行到特殊的陷入指令时：

- 中断/异常机制：硬件保护现成；通过查**中断向量表**把控制权转给系统调用总入口程序。
- 系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查**系统调用表**把控制权转给对应的系统调用例程或内核函数
- 执行系统调用例程
- 恢复现场，返回用户程序